let loadedFont = null;

function loadFontFile(path = "./font/ARIALBD.TTF", callback) {
  opentype.load(path, function (err, font) {
    if (err) {
      console.error("Failed to load font:", err);
    } else {
      loadedFont = font;
      // console.log("Font loaded successfully");
      if (typeof callback === "function") callback(font);
    }
  });
}

function convertSVGShapesToPaths(svgString) {
  // const font = await loadFontIfNeeded();
  const parser = new DOMParser();
  const xmlDoc = parser.parseFromString(svgString, "image/svg+xml");
  const svg = xmlDoc.querySelector("svg");
  xmlDoc.querySelectorAll("defs").forEach(def => def.remove());
  const shapeConverters = {
    rect: (el) => {
      const x = parseFloat(el.getAttribute("x") || 0);
      const y = parseFloat(el.getAttribute("y") || 0);
      const width = parseFloat(el.getAttribute("width"));
      const height = parseFloat(el.getAttribute("height"));
      const rx = parseFloat(el.getAttribute("rx") || 0);
      const ry = parseFloat(el.getAttribute("ry") || 0);

      if (rx || ry) {
        return `M${x + rx},${y} 
          H${x + width - rx} 
          A${rx},${ry} 0 0 1 ${x + width},${y + ry} 
          V${y + height - ry} 
          A${rx},${ry} 0 0 1 ${x + width - rx},${y + height} 
          H${x + rx} 
          A${rx},${ry} 0 0 1 ${x},${y + height - ry} 
          V${y + ry} 
          A${rx},${ry} 0 0 1 ${x + rx},${y} 
          Z`;
      }

      return `M${x},${y} h${width} v${height} h${-width} Z`;
    },

    circle: (el) => {
      const cx = parseFloat(el.getAttribute("cx"));
      const cy = parseFloat(el.getAttribute("cy"));
      const r = parseFloat(el.getAttribute("r"));
      return `M ${cx - r},${cy}
        a ${r},${r} 0 1,0 ${r * 2},0
        a ${r},${r} 0 1,0 ${-r * 2},0`;
    },

    ellipse: (el) => {
      const cx = parseFloat(el.getAttribute("cx"));
      const cy = parseFloat(el.getAttribute("cy"));
      const rx = parseFloat(el.getAttribute("rx"));
      const ry = parseFloat(el.getAttribute("ry"));
      return `M ${cx - rx},${cy}
        a ${rx},${ry} 0 1,0 ${rx * 2},0
        a ${rx},${ry} 0 1,0 ${-rx * 2},0`;
    },

    line: (el) => {
      const x1 = el.getAttribute("x1");
      const y1 = el.getAttribute("y1");
      const x2 = el.getAttribute("x2");
      const y2 = el.getAttribute("y2");
      return `M${x1},${y1} L${x2},${y2}`;
    },

    polyline: (el) => {
      const rawPoints = el.getAttribute("points") || "";
      const coords = rawPoints.trim().split(/[\s,]+/).map(parseFloat);

      if (coords.length < 4) return '';
      let d = `M${coords[0]},${coords[1]}`;
      for (let i = 2; i < coords.length; i += 2) {
        d += ` L${coords[i]},${coords[i + 1]}`;
      }
      return d;
    },

    polygon: (el) => {
      const rawPoints = el.getAttribute("points") || "";
      const coords = rawPoints.trim().split(/[\s,]+/).map(parseFloat);

      if (coords.length < 4) return '';
      let d = `M${coords[0]},${coords[1]}`;
      for (let i = 2; i < coords.length; i += 2) {
        d += ` L${coords[i]},${coords[i + 1]}`;
      }
      d += " Z";
      return d;
    }
  };

  for (const [tag, converter] of Object.entries(shapeConverters)) {
    const elements = xmlDoc.querySelectorAll(tag);
    elements.forEach(el => {
      const d = converter(el);
      if (!d) return;

      const pathEl = document.createElementNS("http://www.w3.org/2000/svg", "path");
      pathEl.setAttribute("d", d);

      // Copy other visual attributes
      for (const attr of el.attributes) {
        if (!["x", "y", "width", "height", "cx", "cy", "r", "rx", "ry", "x1", "y1", "x2", "y2", "points"].includes(attr.name)) {
          pathEl.setAttribute(attr.name, attr.value);
        }
      }

      el.replaceWith(pathEl);
    });
  }
  
  if (loadedFont) {
    const textElements = xmlDoc.querySelectorAll("text");
    textElements.forEach(el => {
      const text = el.textContent.trim();
      const x = parseFloat(el.getAttribute("x") || 0);
      let y = parseFloat(el.getAttribute("y") || 0);

      let fontSize = parseFloat(el.getAttribute("font-size"));
      if (!fontSize) {
        const style = el.getAttribute("style") || "";
        const match = style.match(/font-size\s*:\s*([\d.]+)px/);
        if (match) {
          fontSize = parseFloat(match[1]);
        } else {
          fontSize = 16; // fallback
        }
      }
  
      el.removeAttribute("font-family");
      const style = el.getAttribute("style") || "";
      const newStyle = style.replace(/font-family:[^;"]+;?/gi, "");
      el.setAttribute("style", newStyle.trim());
  
      const path = loadedFont.getPath(text, x, y, fontSize);
      let d = path.toPathData(2);

      const pathEl = document.createElementNS("http://www.w3.org/2000/svg", "path");
      pathEl.setAttribute("d", d);
      pathEl.setAttribute("fill", el.getAttribute("fill") || "black");
        
      el.replaceWith(pathEl);
    });
  }

  flattenGroupTransforms(svg);
  return new XMLSerializer().serializeToString(svg);
}

function getMatrixFromTransform(transform) {
  const match = /matrix\(([^)]+)\)/.exec(transform);
  if (!match) return null;
  return match[1].split(',').map(Number);
}

function applyMatrixToPath(d, matrix) {
  if (!matrix) return d;

  const [a, b, c, dM, e, f] = matrix;

  return d.replace(/([MLCSTQ])([^MLCSTQAZ]*)/gi, (match, command, params) => {
    const nums = params.trim().split(/[\s,]+/).map(parseFloat);
    let transformed = [];

    for (let i = 0; i < nums.length; i += 2) {
      const x = nums[i];
      const y = nums[i + 1];
      if (isNaN(x) || isNaN(y)) continue;

      const xNew = a * x + c * y + e;
      const yNew = b * x + dM * y + f;
      transformed.push(`${xNew},${yNew}`);
    }

    return `${command} ${transformed.join(" ")}`;
  });
}

function estimateStrokeScaleFromMatrix(matrix) {
  if (!matrix) return 1;
  const [a, b] = matrix;
  return Math.sqrt(a * a + b * b); // horizontal component scaling
}

function flattenGroupTransforms(svgEl) {
  const groups = svgEl.querySelectorAll("g[transform]");

  groups.forEach(group => {
    const transformAttr = group.getAttribute("transform");
    const matrix = getMatrixFromTransform(transformAttr);

    const strokeScale = estimateStrokeScaleFromMatrix(matrix); // scale factor for stroke

    group.querySelectorAll("path").forEach(path => {
      const d = path.getAttribute("d");
      const newD = applyMatrixToPath(d, matrix);
      path.setAttribute("d", newD);
      path.removeAttribute("transform");

      const originalStrokeWidth = parseFloat(path.getAttribute("stroke-width"));
      if (!isNaN(originalStrokeWidth)) {
        const newStroke = Math.max(0.5, originalStrokeWidth * strokeScale); // clamp to avoid too thin
        path.setAttribute("stroke-width", newStroke.toFixed(2));
      }

      group.parentNode.insertBefore(path, group);
    });

    group.remove();
  });
}
